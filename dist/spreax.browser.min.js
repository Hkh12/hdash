const Spreax = (function () {
  const t = Node.ELEMENT_NODE; const
    n = Node.TEXT_NODE; const e = function (t, n) { for (var e = '', r = 0; r < t.length; r++)e += t[r], r in n && (e += n[r]); return e; }; const r = function (t, n) { return n.reduce((t, n) => t[n], t); }; const
    i = function (t, n, e) { r(t, n.slice(0, -1))[n[n.length - 1]] = e; }; const a = /^\[([a-z]+)(?::([a-z]+))?\]$/i; const o = {}; const
    u = function (t, n, e) { void 0 === e && (e = !1), this.name = t, this.fn = n, this.paramRequired = e; }; function f(t) { const n = t.name; if (n in o) throw new Error(`already registered ${n}`); if (!/^[a-z]+$/i.test(n)) throw new Error(`${n} is not a valid directive name`); o[n] = t; }u.prototype.apply = function (t, n, e, a) {
    if (this.paramRequired && !e) throw new Error(`parameter is required for ${this.name} directive`); this.fn.call(t, {
      element: n,
      param: e,
      rawValue: a,
      value: a ? (function t(n) {
        const e = (function (t) { const n = function (t) { return { done: !0, value: t }; }; return /^\d+(?:\.\d*)?$/.test(t) ? n(+t) : /^(['"`]).*\1$/.test(t) ? n(t.slice(1, -1)) : /^:[a-z]*$/.test(t) ? n(t.slice(1)) : t === 'true' ? n(!0) : t === 'false' ? n(!1) : t === 'undefined' ? n(void 0) : t === 'null' ? n(null) : t === 'Infinity' ? n(1 / 0) : { done: !1 }; }(n = n.trim())); if (e.done) return { type: 'literal', fn() { return e.value; } }; const a = (n.match(/^(?:[a-z_]+\.)*[a-z_]+$/i) || [])[0]; if (a) {
          const o = a.split('.'); return {
            type: 'property', property: a, path: o, fn(t) { return r(t, o); },
          };
        } const u = (n.match(/^([a-z_]\w+)\(\)$/i) || [])[1]; if (u) return { type: 'action', isMethod: !0, fn(t) { return t[u](); } }; const f = n.match(/^(.+) ?= ?(.+)$/) || []; if (f.length) {
          const c = f.slice(1).map((n) => t(n.trim())); const v = c[0]; const
            s = c[1]; if (v.type !== 'property' || s.type === 'action' && !s.isMethod) throw new Error('da fuck'); return {
            type: 'action', isMethod: !1, rightHand: s, fn(t) { i(t, v.path, s.fn(t)); },
          };
        }
      }(a)) : void 0,
    });
  }; const c = new u('on', function (t) {
    const n = this; const e = t.element; const r = t.param; const
      i = t.value; e.addEventListener(r, () => { i.type === 'action' && i.fn(n); });
  }, !0); const
    v = new u('bind', function (t) {
      const n = this; const e = t.element; const r = t.rawValue; const
        a = t.value; a.type === 'property' && r === a.property && (this.$on(a.property, () => { e.value = a.fn(n); }, { immediate: !0 }), e.addEventListener('keydown', () => { setTimeout(() => { i(n, a.path, e.value); }, 0); }));
    }); f(c), f(v); const s = function (e) {
    const r = this; const i = e.el; const a = e.state; const
      o = e.methods; i._sp = this, this.$el = i, this.$events = [], this.$state = (function t(n, e, r) {
      void 0 === r && (r = []); const i = {}; return new Proxy(n, {
        get(n, a) {
          const o = n[a]; if (typeof o === 'object') {
            const u = r.concat([a]); const
              f = u.join('.'); return f in i || (i[f] = t(o, e, u)), i[f];
          } return o;
        },
        set(n, a, o) {
          const u = r.concat([a]); const
            f = u.join('.'); f in i && (i[f] = t(o, e, u)); const c = n[a]; if (c === o) return !1; n[a] = o, e(u, c, o);
        },
      });
    }(a, (t) => { r.$emit(t.join('.')); })); const u = function (t) { Object.defineProperty(r, t, { get() { return r.$state[t]; }, set(n) { r.$state[t] = n; } }); }; for (const f in r.$state)u(f); for (const c in o)r[c] = o[c].bind(r); (function e(r) { return Array.from(r.childNodes).filter((e) => [t, n].includes(e.nodeType)).map((t) => [t].concat(e(t))).flat(1 / 0); }(i)).forEach((t) => r.$handleNode(t));
  }; return s.prototype.$handleNode = function (t) {
    let n; const
      i = this; if (t.nodeName === '#text') {
      const u = t.textContent; if (/^\s*$/.test(u)) return; for (var f = (function (t) {
          const n = /\{ ?(?:\w+\.)*\w+ ?\}/g; const i = (t.match(n) || []).map((t) => t.slice(1, -1).trim()); const
            a = t.split(n); return { vars: i, render(t) { return e(a, i.map((n) => r(t, n.split('.')))); } };
        }(u)), c = 0, v = f.vars; c < v.length; c += 1) { const s = v[c]; i.$on(s, () => { t.textContent = f.render(i.$state); }, { immediate: !0 }); }
    } else {
      for (let p = 0, d = (n = t, Array.from(n.attributes).filter((t) => { const n = t.name; return a.test(n); }).map((t) => {
        const n = t.name; const e = t.value; const r = a.exec(n); const
          i = r[1]; return { param: r[2], value: e, name: i };
      })); p < d.length; p += 1) {
        const l = d[p]; const h = l.value; const m = l.name; const
          y = l.param; m in o && o[m].apply(i, t, y, h);
      }
    }
  }, s.prototype.$on = function (t, n, e) { void 0 === e && (e = {}); let r = e.immediate; void 0 === r && (r = !1); const i = this.$events.push({ key: t, fn: n.bind(this) }) - 1; r && this.$emit(i); }, s.prototype.$emit = function (t) { for (let n = this.$events, e = 0; e < n.length; e++) { const r = n[e]; (typeof t === 'number' ? e : r.key) === t && r.fn(); } }, s;
}());
